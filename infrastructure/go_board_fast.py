from numpy import block
from .stone import *

from copy import copy, deepcopy
from typing import Union


class BoardPosition(Enum):
    Bulk = 0
    Left = 1
    Right = 2
    Bottom = 3
    Top = 4
    BottomLeftCorner = 5
    BottomRightCorner = 6
    TopLeftCorner = 7
    TopRightCorner = 8


class StoneBlock:
    """ ```
    ### Block of Stones
    This is the most fundamental data structure to implement the go rules
    > `block_color` describe the color of the entire block
    > `stone_pos_hashset` stores all positions `[x,y]` as a set for fast query
    > `block_id` stores the *unique* hash id for each block, this is generated by `hash(str(self.stone_pos_hashset))`

    ```"""
    block_color: Color
    stone_pos_hashset: set[tuple[int,int]]
    block_id: int


    def __init__(self, block_color: Color, stone_pos_hashset: set[tuple[int,int]]) -> None:
        """initlize the empty block of stones"""
        self.block_color = block_color
        self.stone_pos_hashset = stone_pos_hashset
        self.block_id = hash(str(stone_pos_hashset))
        
    def __repr__(self) -> str:
        block_str = f"{self.block_color} "
        block_str += f"{list(self.stone_pos_hashset)[0]}..."        
        return block_str




class GoBoard:
    """```
    ### Go Board Class
    - `size` tells the board shape
    - `current_move_color` stores the color of stone to be place. It will be used for generataion of the next move with the alternating rule
    
    - `block_id_to_stone_block_hashmap` stores the hashmap from the *unique* `block_id` to the `StoneBlock`
    - `full_stone_pos_to_color_hashmap` stores the splashed hashmap from *all* stones' position to the color on board

    - `block_id_to_block_nearby_empty_site_hashset_hashmap`  the hashmap from the *unique* `block_id` to the set constructed from all positions `[x,y]` of nearby empty sites for every stone block

    Note: we set black first by default, initialize the board with `black_first=False` to switch this
    ```"""
    size: tuple[int, int]
    komi: float
    consecutive_passes: int
    current_move_color: Color # alternating color for each move

    block_id_to_stone_block_hashmap: dict[int, StoneBlock]
    full_stone_pos_to_color_hashmap: dict[tuple[int, int], Color]
    block_id_to_block_nearby_empty_site_hashset_hashmap: dict[int, set[tuple[int,int]]]
    block_id_to_block_liberty_site_hashset_hashmap: dict[int, set[tuple[int,int]]]
    block_id_to_block_single_eye_site_hashset_hashmap: dict[int, set[tuple[int,int]]]
    full_site_to_nearby_block_id_list_hashmap: dict[tuple[int, int], list[int]]

    # allowed_searching_site_hashset: set[tuple[int,int]]

    
    def __init__(self, size: tuple[int, int] = (19,19), black_first: bool = True) -> None:
        self.size = size
        self.komi = 7.5
        self.consecutive_passes = 0
        self.current_move_color = Color.Black if black_first else Color.White
        self.block_id_to_stone_block_hashmap: dict[int, StoneBlock] = {}
        self.full_stone_pos_to_color_hashmap: dict[tuple[int, int], Color] = {}
        self.block_id_to_block_nearby_empty_site_hashset_hashmap: dict[int, set[tuple[int,int]]] = {}
        self.block_id_to_block_liberty_site_hashset_hashmap: dict[int, set[tuple[int,int]]] = {}
        self.block_id_to_block_single_eye_site_hashset_hashmap: dict[int, set[tuple[int,int]]] = {}
        self.full_site_to_nearby_block_id_list_hashmap: dict[tuple[int, int], list[int]] = {}
        # self.allowed_searching_site_hashset: set[tuple[int,int]] = set([(i,j) for i in range(0, size[0]) for j in range(0, size[1])])
    
    def __repr__(self) -> str:
        board_str = f"current board: (board size: {self.size})\n"
        for i in range(self.size[0],-1,-1):
            for j in range(0,self.size[1]+1):
                pos = (j,i)
                if pos in self.full_stone_pos_to_color_hashmap:
                    board_str += f" {self.full_stone_pos_to_color_hashmap[pos]}"
                elif j <= self.size[1]-1 and i < self.size[0] and i != -1:
                    board_str += "  +"

                if j == self.size[1]-1:
                    board_str += "\n "
                if j == self.size[1] and i-1 >= 0:
                    board_str += f"{i-1:2d}"

        board_str += "   "
        for x in range(0,self.size[1]):
            board_str += f"{x:2d} "
        board_str += "\n"

        return board_str

    def get_board_position(self, pos: tuple[int, int]) -> BoardPosition:
        """for rectangular board only"""
        (N1, N2) = self.size
        (N1, N2) = (N1-1, N2-1)
        # (i, j) = pos
        assert 0 <= pos[0] <= N1 and 0 <= pos[1] <= N2
        match pos:
            case (0, 0): return BoardPosition.BottomLeftCorner
            case (i, 0) if i == N1: return BoardPosition.BottomRightCorner
            case (0, j) if j == N2: return BoardPosition.TopLeftCorner
            case (i, j) if i == N1 and j == N2: return BoardPosition.TopRightCorner
            case (0, j) if j > 0: return BoardPosition.Left
            case (i, j) if i == N1 and j > 0: return BoardPosition.Right
            case (i, 0) if i > 0: return BoardPosition.Bottom
            case (i, j) if i > 0 and j == N2: return BoardPosition.Top
            case _: return BoardPosition.Bulk

    def get_nearby_sites_for_position(self, pos: tuple[int, int]) -> list[tuple[int,int]]:
        (x,y) = pos
        match self.get_board_position(pos):
            case BoardPosition.Bulk: return [(x+1,y), (x-1,y), (x,y+1), (x,y-1)]
            case BoardPosition.Left: return [(x+1,y), (x,y+1), (x,y-1)]
            case BoardPosition.Right: return [(x-1,y), (x,y+1), (x,y-1)]
            case BoardPosition.Bottom: return [(x+1,y), (x-1,y), (x,y+1)]
            case BoardPosition.Top: return [(x+1,y), (x-1,y), (x,y-1)]
            case BoardPosition.BottomLeftCorner: return [(x+1,y), (x,y+1)]
            case BoardPosition.BottomRightCorner: return [(x-1,y), (x,y+1)]
            case BoardPosition.TopLeftCorner: return [(x+1,y), (x,y-1)]
            case BoardPosition.TopRightCorner: return [(x-1,y), (x,y-1)]


    def update_block_id_to_stone_block_hashmap(self, stone: Stone):
        # if the site is occupied, do nothing.
        # otherwise, the stone to be placed can still be adjacent to the existing stone blocks, where stone-block or block-block merge may occur
        if stone.pos not in self.full_stone_pos_to_color_hashmap:
            # start with a new single-stone block
            new_stone_block = StoneBlock(stone.color, set([stone.pos]))
            block_id_list_to_be_removed: list[int] = []
            for (block_id, block_nearby_sites) in self.block_id_to_block_nearby_empty_site_hashset_hashmap.items():
                stone_block = self.block_id_to_stone_block_hashmap[block_id]
                if stone.pos in block_nearby_sites and stone.color == stone_block.block_color:
                    new_stone_block.stone_pos_hashset.update(stone_block.stone_pos_hashset) # block merge
                    block_id_list_to_be_removed.append(block_id)
            
            new_stone_block_id = hash(str(new_stone_block.stone_pos_hashset))
            new_stone_block.block_id = new_stone_block_id
            self.block_id_to_stone_block_hashmap[new_stone_block_id] = new_stone_block

            # remove merged block keys
            for block_id in block_id_list_to_be_removed:
                del self.block_id_to_stone_block_hashmap[block_id]


    def update_full_stone_pos_to_color_hashmap(self):
        # refresh with a new board
        self.full_stone_pos_to_color_hashmap: dict[tuple[int,int], Color] = {};
        for (_, stone_block) in self.block_id_to_stone_block_hashmap.items():
            for pos in stone_block.stone_pos_hashset:
                self.full_stone_pos_to_color_hashmap[pos] = stone_block.block_color

    def update_block_id_to_block_nearby_empty_site_hashset_hashmap(self):
        # first, remove redundant keys
        redundant_keys = [k for k in self.block_id_to_block_nearby_empty_site_hashset_hashmap if k not in self.block_id_to_stone_block_hashmap]
        for k in redundant_keys:
            del self.block_id_to_block_nearby_empty_site_hashset_hashmap[k]

        # loop through each stone block to identify and add the nearest-nearby empty sites
        for (block_id, stone_block) in self.block_id_to_stone_block_hashmap.items():
            empty_site_hashset: set[tuple[int,int]] = set() # empty sites for this specific block
            for pos in stone_block.stone_pos_hashset:
                nearby_sites = self.get_nearby_sites_for_position(pos)
                for site in nearby_sites:
                    # if is not occupied
                    if site not in self.full_stone_pos_to_color_hashmap:
                        empty_site_hashset.add(site)

            self.block_id_to_block_nearby_empty_site_hashset_hashmap[block_id] = empty_site_hashset


    def _is_single_eye(self, pos: tuple[int,int]) -> bool:
        nearby_sites_for_given_site = self.get_nearby_sites_for_position(pos)
        nearby_sites_color_hashset: set[Color] = set()
        for site in nearby_sites_for_given_site:
            site_color = self.full_stone_pos_to_color_hashmap.get(site)
            if site_color is None:
                return False
            else:
                nearby_sites_color_hashset.add(site_color)
        if len(nearby_sites_color_hashset) == 1:
            return True
        else:
            return False 

    def _single_eye_color(self, pos: tuple[int,int]) -> Union[Color, None]:
        nearby_sites_for_given_site = self.get_nearby_sites_for_position(pos)
        nearby_sites_color_hashset: set[Color] = set()
        for site in nearby_sites_for_given_site:
            site_color = self.full_stone_pos_to_color_hashmap.get(site)
            if site_color is None:
                return None
            else:
                nearby_sites_color_hashset.add(site_color)
        if len(nearby_sites_color_hashset) == 1:
            return nearby_sites_color_hashset.pop()
        else:
            return None 


    def update_block_id_to_block_liberty_site_and_block_single_eye_site_hashmap(self):
        # first, remove redundant keys
        redundant_keys = [k for k in self.block_id_to_block_liberty_site_hashset_hashmap if k not in self.block_id_to_stone_block_hashmap]
        for k in redundant_keys:
            del self.block_id_to_block_liberty_site_hashset_hashmap[k]
        # first, remove redundant keys
        redundant_keys = [k for k in self.block_id_to_block_single_eye_site_hashset_hashmap if k not in self.block_id_to_stone_block_hashmap]
        for k in redundant_keys:
            del self.block_id_to_block_single_eye_site_hashset_hashmap[k]

        for (block_id, empty_site_hashset) in self.block_id_to_block_nearby_empty_site_hashset_hashmap.items():
            block_liberty_site_hashset = set()
            block_single_eye_site_hashset = set()
            # break_flat_for_current_empty_site = False
            for current_empty_site in empty_site_hashset:
                block_liberty_site_hashset.add(current_empty_site)
                if self._is_single_eye(current_empty_site):
                    block_single_eye_site_hashset.add(current_empty_site)
            
            self.block_id_to_block_liberty_site_hashset_hashmap[block_id] = block_liberty_site_hashset
            self.block_id_to_block_single_eye_site_hashset_hashmap[block_id] = block_single_eye_site_hashset

    def update_full_site_to_nearby_block_id_list_hashmap(self):
        # build a fully new one, or cover the entire existing hashmap
        for i in range(0, self.size[0]):
            for j in range(0, self.size[1]):
                nearby_sites = self.get_nearby_sites_for_position((i,j))
                block_id_list: list[int] = []
                for site in nearby_sites:
                    if site in self.full_stone_pos_to_color_hashmap:
                        for (block_id, stone_block) in self.block_id_to_stone_block_hashmap.items():
                            if site in stone_block.stone_pos_hashset:
                                block_id_list.append(block_id)

                self.full_site_to_nearby_block_id_list_hashmap[(i,j)] = list(set(block_id_list))

    def _is_capture_move(self, pos: tuple[int,int]) -> bool:
        nearby_block_id_list = self.full_site_to_nearby_block_id_list_hashmap.get(pos,[]);
        if len(nearby_block_id_list) == 0:
            return False
        else: # if `len(nearby_block_id_list) != 0`
            for block_id in nearby_block_id_list:
                block_color = self.block_id_to_stone_block_hashmap[block_id].block_color
                block_liberty_site_hashset = self.block_id_to_block_liberty_site_hashset_hashmap[block_id]
                if block_color == self.current_move_color.alternate() and len(block_liberty_site_hashset) == 1:
                    return True
            return False

    def _is_suicide_move(self, pos: tuple[int,int]) -> bool:
        nearby_site_list = self.get_nearby_sites_for_position(pos);
        for site in nearby_site_list:
            if self.full_stone_pos_to_color_hashmap.get(site) == None:
                # empty site exists even after placing the move, so cannot be suicide
                return False
        
        # now every nearby site is occupied (of either current move color or opponent color)
        nearby_block_id_list = self.full_site_to_nearby_block_id_list_hashmap.get(pos, []);
        
        block_counter_of_opponent_color = 0;
        block_counter_of_current_move_color = 0;
        block_counter_of_current_move_color_with_one_liberty = 0;
        for block_id in nearby_block_id_list:
            block_color = self.block_id_to_stone_block_hashmap[block_id].block_color
            block_liberty_site_hashset = self.block_id_to_block_liberty_site_hashset_hashmap[block_id]
            if block_color == self.current_move_color:
                block_counter_of_current_move_color += 1;
                if len(block_liberty_site_hashset) > 1:
                    # if contains some blocks of current move with liberty > 1, then after place the move these blocks will be connected and the resulting liberty is > 0, so is NOT a suicide
                    return False
                else:
                    block_counter_of_current_move_color_with_one_liberty += 1
            else:
                block_counter_of_opponent_color += 1

        if block_counter_of_current_move_color == block_counter_of_current_move_color_with_one_liberty and block_counter_of_current_move_color > 0:
            # if all nearby sites are of current move color, and all of them share the one liberty
            return True
        if  block_counter_of_current_move_color == block_counter_of_current_move_color_with_one_liberty == 0 and block_counter_of_opponent_color > 0:
            # if all nearby sites are of opponent color
            return True

        return False


    def execute_capture_after_move_is_placed(self, pos: tuple[int,int]):
        nearby_block_id_list = self.full_site_to_nearby_block_id_list_hashmap.get(pos, [])
        captured_block_id_list: list[int] = []
        for block_id in nearby_block_id_list:
            block_color = self.block_id_to_stone_block_hashmap[block_id].block_color
            block_liberty_site_hashset = self.block_id_to_block_liberty_site_hashset_hashmap[block_id]
            if block_color == self.current_move_color.alternate() and len(block_liberty_site_hashset) == 0:
                captured_block_id_list.append(block_id)
        # print(f"\tblock to be removed: `hash_id` = {captured_block_id_list}")
        for block_id in captured_block_id_list:
            del self.block_id_to_stone_block_hashmap[block_id]

        self.update_all_go_board_data()


    def update_all_go_board_data(self):
        # the update order here is crucial!!!
        self.update_full_stone_pos_to_color_hashmap();
        self.update_block_id_to_block_nearby_empty_site_hashset_hashmap();
        self.update_full_site_to_nearby_block_id_list_hashmap();
        self.update_block_id_to_block_liberty_site_and_block_single_eye_site_hashmap();
    

    def place_stone_at(self, pos: tuple[int,int], show_board: bool = False) -> Union[None, tuple[bool, bool]]:
        if pos in self.full_stone_pos_to_color_hashmap:
            # illegal move: already occupied!
            return None
        else:
            move_stone = Stone(self.current_move_color, pos)

            _is_capture_move = self._is_capture_move(pos)
            _is_suicide_move = self._is_suicide_move(pos)
            # print(f"move{self.current_move_color} at {pos}\t`_is_capture` = {_is_capture_move}, `_is_suicide` = {_is_suicide_move}");
            match (_is_capture_move, _is_suicide_move):
                case (False, False): 
                    # normal move
                    self.update_block_id_to_stone_block_hashmap(move_stone);
                    self.update_all_go_board_data();
                    self.current_move_color = self.current_move_color.alternate();
                    if show_board:
                        print(self)
                    return (False, False)
                case (True, x):
                    # simple capture, or suicide with capture
                    self.update_block_id_to_stone_block_hashmap(move_stone);
                    self.update_all_go_board_data();
                    self.execute_capture_after_move_is_placed(pos);
                    self.update_all_go_board_data();
                    self.current_move_color = self.current_move_color.alternate();
                    if show_board:
                        print(self)
                    return (True, x)
                case (False, True):
                    # do nothing to the go_board
                    # print(f"\tmove {pos} is detected to be suicide!")
                    # self.pass_move()
                    return (False, True)
   
   
    def pass_move(self) -> None:
        "switch color"
        print(f"MOVE{self.current_move_color} PASSED!!!")
        self.current_move_color = self.current_move_color.alternate()
        print(self)


    # def _is_illegal_move_for_current_player(self, pos: tuple[int,int]) -> bool:
    #     """
    #     consider a test board to see if is illegal for currnet player to place a move at `pos`
    #     > Note: this method will NOT mutate the given board!
    #     """
    #     test_board = deepcopy(self)
    #     match test_board.place_stone_at(pos, show_board=False):
    #         case None | (False, True): 
    #             return True
    #         case _:
    #             return False

    # def _is_illegal_move_for_opponent(self, pos: tuple[int,int]) -> bool:
    #     """
    #     consider a test board to see if is illegal for opponent to place a move at `pos`
    #     > Note: this method will NOT mutate the given board!
    #     """
    #     test_board = deepcopy(self)
    #     # swich the color for a test move to see if the empty site `pos` is an illegal point
    #     test_board.current_move_color = self.current_move_color.alternate()
    #     match test_board.place_stone_at(pos, show_board=False):
    #         case None | (False, True): 
    #             return True
    #         case _:
    #             return False

    # def _is_site_need_to_be_cautious(self, pos:tuple[int,int]) -> bool:
    #     nearby_site_list = self.get_nearby_sites_for_position(pos)
    #     adjacent_count = 0
    #     for site in nearby_site_list:
    #         if site in self.full_stone_pos_to_color_hashmap:
    #             adjacent_count += 1
    #     if adjacent_count == len(nearby_site_list):
    #         if self._is_single_eye(pos):
    #             eye_color = self._single_eye_color(pos)
    #             return True
    #         else:
    #             nearby_block_id_list = self.full_site_to_nearby_block_id_list_hashmap.get(pos,[])
    #             for block_id in nearby_block_id_list:
    #                 block_liberty = len(self.block_id_to_block_liberty_site_hashset_hashmap[block_id])
    #                 block_single_eye = len(self.block_id_to_block_single_eye_site_hashset_hashmap[block_id])
    #                 if block_liberty <= 1 or block_single_eye <= 2:
    #                     return True
    #                 else:
    #                     return False
    #     return False




def score_board(go_board: GoBoard) -> tuple[tuple[Color,int], tuple[Color,int]]:
    # count Black
    black_score = 0
    white_score = 0
    for stone_block in go_board.block_id_to_stone_block_hashmap.values():
        match stone_block.block_color:
            case Color.Black: black_score += len(stone_block.stone_pos_hashset)
            case Color.White: white_score += len(stone_block.stone_pos_hashset)
    
    return ((Color.Black, black_score), (Color.White, white_score))

